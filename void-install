#!/usr/bin/env bash

#  void-install
#  Created: 2022/12/24
#  Altered: 2022/12/26
#
#  Copyright (c) 2022-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#                2022-2022, Felipe Nogueira <contato.fnog@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#debug
#export PS4=$'${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x

#system
APP="${0##*/}"
_VERSION_='1.1.20221226'
readonly DEPENDENCIES=(tar wget sed cat chroot tput printf blkid fdisk mkfs.ext4 mkfs.ext2 dialog sfdisk lsblk)
declare -A AsUser

sh_ambiente() {
	#export LC_ALL=C
	#export LANG=C
	readonly dir_install='/mnt/voidlinux'
	readonly app_conf='void-install.conf'
	readonly BOOTLOG='/tmp/void-install.log'
	readonly URL_GOOGLE='https://google.com'
	readonly url_mirror='http://void.chililinux.com/voidlinux'
	readonly cmsgusermanager="$APP v$_VERSION_ configuracao"
	readonly ccreatenewuser='Configurações'
	readonly cmsgadduser='Aguarde, criando usuario'
	readonly cdisco='DISCO'
 	readonly cchoosedisk='Escolha o disco:'
	readonly cmsg_part_disk='Visualizar partições do disco'
   readonly buttonOK='Accept'
   readonly buttonCancel='Cancel'
	readonly buttonback='Finalizar'
   readonly buttonpart='Info disco'
	readonly grafico=0
	readonly true=1
	readonly false=0
	: "${ccabec="$APP ${_VERSION_}"}"
	: "${DIALOG=${DIALOG:-"dialog"}}"
	# flag dialog exit status codes
   : "${D_OK=0}"
   : "${D_CANCEL=1}"
   : "${D_HELP=2}"
   : "${D_EXTRA=3}"
   : "${D_ITEM_HELP=4}"
   : "${D_ESC=255}"
	: echo "$tarball"

	if [ -z "${COLUMNS}" ]; then
   	COLUMNS=$(stty size)
	   COLUMNS=${COLUMNS##* }
	fi
	if [ "${COLUMNS}" = "0" ]; then
   	COLUMNS=80
	fi
	COL=$((COLUMNS - 8))
	SET_COL="\\033[${COL}G" # at the $COL char
	CURS_ZERO="\\033[0G"
}

sh_touchconf(){
   cat > "$app_conf" <<- EOF
######################################################################
# void-install.conf
# Gerado por void-install
######################################################################
_CONFIG='1'
_DEVICE='/dev/loop11'
_PART_BIOS="/dev/loop11p1"
_PART_BOOT="/dev/loop11p2"
_PART_ROOT="/dev/loop11p3"
_TARBALL_ROOTFS='void-x86_64-ROOTFS-20221001.tar.xz'
_USER="void"
_PASSWD_USER="void"
_PASSWD_ROOT="root"
_HOSTNAME="voidlinux"
_TIMEZONE="America/Porto_Velho"
_KEYMAP="br-abnt2"
_CLOCK="UTC"
_PKGS="vim"
#end
EOF
}

sh_config() {
	[[ -s "$app_conf" ]] || sh_touchconf
	# shellcheck source=/dev/null
	if 	[[ -f "$app_conf" ]]
	then 	source "$app_conf"
	else  die "ERRO: falha na abertura de $app_conf!"
	fi
	sh_setadduser
}

sh_ascii_lines() {
	if [[ "$LANG" =~ 'UTF-8' ]]; then
		export NCURSES_NO_UTF8_ACS=0
	else
		export NCURSES_NO_UTF8_ACS=1
	fi
}

sh_checkroot()
{
	if [ "$(id -u)" != "0" ]; then
		printf "%s\n" "${red} error: You cannot perform this operation unless you are root!"
		exit 1
   fi
}

sh_checknet() {
   xurl="$1"
   # have internet?
	msg "INFO" "$(log_info_msg "Testando internet em ${xurl}")"
   curl --insecure "$xurl" >/dev/null 2>&1 ||
      {
         evaluate_retval "$?"
         die "Sem rota para o servidor ($xurl) - Check sua conexão com a internet!"
		   return 1
      }
   evaluate_retval "$?"
   return $?
}

sh_checktarball() {
	msg "INFO" "$(log_info_msg "Checando existência do tarball rootfs $_TARBALL_ROOTFS")"
	if ! test -r "$_TARBALL_ROOTFS"; then
	   evaluate_retval 1
		msg "INFO" "$(log_info_msg "Tarball rootfs $_TARBALL_ROOTFS não localizado. Procedendoo com download")"
		curl --insecure --silent --remote-name "$url_mirror/live/current/$_TARBALL_ROOTFS" >/dev/null 2>&1 ||
      {
         evaluate_retval "$?"
         die "Sem rota para o servidor ($url_mirror) - Check sua conexão com a internet!"
		   return 1
      }
	fi
	evaluate_retval 0
   return $?
}

checkDependencies()
{
	local errorFound=0
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		[[ -z $(command -v "$d") ]] && missing+=("$d") && errorFound=1 && printf '%s\n' "${red}ERRO${reset}: não encontrei o comando ${cyan}'$d'${reset}"
	done
	if (( errorFound )); then
		echo "---IMPOSSÍVEL CONTINUAR---"
		echo "Esse script precisa dos comandos listados acima" >&2
		echo "Instale-os e/ou verifique se estão no seu \$PATH" >&2
		exit 1
	fi
}

setvarcolors() {
   reset=$(tput sgr0);        green=$(tput setaf 2);  red=$(tput setaf 124);
   pink=$(tput setaf 129);    bold=$(tput bold);      blue=$(tput setaf 33);
	cyan=$(tput setaf 37);
   #yellow=$(tput setaf 136);
	#orange=$(tput setaf 166);
   #white=$(tput setaf 15);
   #violet=$(tput setaf 61);
	#purple=$(tput setaf 125);
}

unsetvarcolors() {
   reset='' green='' red='' pink='' bold='' blue='' cyan=''
	#yellow=''
	#orange=''
	#white=''
	#violet=''
   #purple=''
   NORMAL='' SUCCESS='' FAILURE='' BRACKET='' CURS_ZERO='' SUCCESS_PREFIX=''
   SET_COL='' SUCCESS_SUFFIX=''
}

log_prefix() {
   NORMAL="${reset}"   # Standard console grey
   SUCCESS="${green}"  # Success is green
   WARNING="${yellow}" # Warnings are yellow
   FAILURE="${red}"    # Failures are red
   BRACKET="${blue}" # Brackets are blue
   BMPREFIX="     "
   DOTPREFIX="  ${blue}::${reset} "
   SUCCESS_PREFIX="${SUCCESS}  *  ${NORMAL}"
   FAILURE_PREFIX="${FAILURE}*****${NORMAL}"
   WARNING_PREFIX="${WARNING}  W  ${NORMAL}"
   SUCCESS_SUFFIX="${BRACKET}[${SUCCESS}  OK  ${BRACKET}]${NORMAL}"
   FAILURE_SUFFIX="${BRACKET}[${FAILURE} FAIL ${BRACKET}]${NORMAL}"
   WARNING_SUFFIX="${BRACKET}[${WARNING} WARN ${BRACKET}]${NORMAL}"
   WAIT_PREFIX="${WARNING}  R  ${NORMAL}"
   WAIT_SUFFIX="${BRACKET}[${WARNING} WAIT ${BRACKET}]${NORMAL}"
   FAILURE_PREFIX="${FAILURE}  X  ${NORMAL}"
}

replicate() {
   local Var
   printf -v Var %"$2s" " "  #  Coloca em $Var $1 espaços
   echo "${Var// /$1}"       #  Troca os espaços pelo caractere escolhido
}

DOT() {
	printf "%s" "${blue}:: ${reset}"
}

log_info_msg() {
	last_msg="$@"
	echo -n -e "${BMPREFIX}${@}"
	return 0
}

evaluate_retval() {
   local error_value="$?"

   if [ $# -gt 0 ]; then
      error_value="$1"
   fi

	if [ "${error_value}" = 0 ]; then
   	log_success_msg2 ''
	else
   	log_failure_msg2 ''
   fi
   return "${error_value}"
}

log_failure_msg2() {
   echo -n -e "${BMPREFIX}${@}"
   echo    -e  "${CURS_ZERO}${FAILURE_PREFIX}${SET_COL}${FAILURE_SUFFIX}"
	logmessage=$(sed 's/\\\033[^a-zA-Z]*.//g' <<< $last_msg)
	echo -e "$(timespec) ${logmessage} OK" >> "${BOOTLOG}"
   return 0
}

log_success_msg()
{
	echo -n -e "${BMPREFIX}${@}"
	echo    -e "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	logmessage=$(sed 's/\\\033[^a-zA-Z]*.//g' <<< $last_msg)
	echo -e "$(timespec) ${logmessage} OK" >> "${BOOTLOG}"
	return 0
}

log_success_msg2() {
   echo -n -e "${BMPREFIX}${@}"
   echo    -e  "${CURS_ZERO}${SUCCESS_PREFIX}${SET_COL}${SUCCESS_SUFFIX}"
	logmessage=$(sed 's/\\\033[^a-zA-Z]*.//g' <<< $last_msg)
	echo -e "$(timespec) ${logmessage} OK" >> "${BOOTLOG}"
   return 0
}

timespec() {
	STAMP="$(echo `date +"%b %d %T %:z"` `hostname`) [$FUNCNAME][$LINENO]"
	echo "$STAMP"
	return 0
}

msg() {
   if (( grafico )); then
      ${DIALOG}               \
      --no-collapse           \
      --title     "$1"        \
      --backtitle "$ccabec"   \
      --infobox   "\n$2"      \
      10 60
   else
      log_info_msg "$2"
   fi
}

die() {
	if test $# -ge 2; then
		evaluate_retval 1
	fi
   local msg=$1; shift
	printf "%-75s\n" "$(DOT)${bold}${red}$msg${reset}" >&2
   exit 1
}

readconf()
{
   read -r -p "$1 [Y/n]"
   [[ ${REPLY^} == "" ]] && return $false
   [[ ${REPLY^} == N ]]  && return $true || return $false
}

conf() {
   ${DIALOG}                     \
      --title     "$1"           \
      --backtitle "$ccabec"      \
      --yes-label "$yeslabel"    \
      --no-label  "$nolabel"     \
      --yesno     "$2"           \
      10 100
   return $?
}


sh_testdisk(){
	local result=0
	fdisk -l "$_DEVICE" > /dev/null 2>&1
	result="$?"
	evaluate_retval "$result"
	return "$result"
}

sh_mkparted(){
	msg "INFO" "$(log_info_msg "Testando disco ${_DEVICE} configurado em $app_conf")"
	if ! sh_testdisk; then
		die "Erro de leitura de disco: $_DEVICE. Check configuração em $app_conf"
	fi
	replicate "=" "$COLUMNS"
	if ! fdisk -l "$_DEVICE"; then
		die "Erro de leitura de disco: $_DEVICE. Check configuração em $app_conf"
	fi
	replicate "=" "$COLUMNS"
	echo "${red}AVISO, CUIDADO, tudo será apagado!!${reset}"
	replicate "=" "$COLUMNS"
	if readconf "Continuar com o particionamento em ${_DEVICE} ?" ; then
		msg "INFO" "$(log_info_msg "Criando partições em ${_DEVICE}")"
	   parted --script "$_DEVICE" --                                   		\
	      mklabel gpt                                                       \
	      mkpart primary fat32      1MiB 3MiB   set 1 bios on name 1 BIOS   \
	      mkpart primary fat32      3MiB 128MiB set 2 esp  on name 2 EFI    \
	      mkpart primary ext4       128MiB 100%               name 3 ROOT   \
	      align-check optimal 1
		evaluate_retval "$?"
		#parted --script "$_DEVICE" -- print
	else
		die "Finalizando..."
	fi
}

sh_update_mirror() {
	msg "INFO" "$(log_info_msg "Atualizando mirror em $dir_install")"
	cat > "$dir_install/etc/xbps.d/00-reposytory-main.conf" <<- EOF
repository=$url_mirror/current
repository=$url_mirror/current/nonfree
repository=$url_mirror/current/multilib
repository=$url_mirror/current/multilib/nonfree
EOF
	evaluate_retval "$?"
}

sh_update_rc() {
	msg "INFO" "$(log_info_msg "Ajustando rc.local em $dir_install")"
	cat > "$dir_install"/etc/rc.local <<- EOF
HOSTNAME="${_HOSTNAME}"
HARDWARECLOCK="${_CLOCK}"
TIMEZONE="${_TIMEZONE}"
KEYMAP="${_KEYMAP}"
EOF
	evaluate_retval "$?"
}

sh_update_locale() {
	msg "INFO" "$(log_info_msg "Ajustando locale.conf em $dir_install")"
	cat > "$dir_install/etc/locale.conf" <<- EOF
LANG=en_US.UTF-8
LC_COLLATE=C
LC_ALL=en_US.UTF-8
EOF
	evaluate_retval "$?"
}

sh_update_hostname() {
	msg "INFO" "$(log_info_msg "Ajustando hostname em $dir_install")"
	echo "${_HOSTNAME}" > $dir_install/etc/hostname
	evaluate_retval "$?"
}

sh_update_timezone() {
	msg "INFO" "$(log_info_msg "Ajustando timezone em $dir_install")"
	sed -e "/en_US.UTF-8 UTF-8/s/^\#//" -i "$dir_install/etc/default/libc-locales"
	sed -e "/pt_BR.UTF-8 UTF-8/s/^\#//" -i "$dir_install/etc/default/libc-locales"
	ln -sf "$dir_install/usr/share/zoneinfo/${_TIMEZONE}" "$dir_install/etc/localtime"
	evaluate_retval "$?"
}

sh_set_keymap(){
	msg "INFO" "$(log_info_msg "Ajustando teclado em $dir_install")"
   [[ ! -e $dir_install/etc/vconsole.conf  ]] && >| $dir_install/etc/vconsole.conf
	if [[ -f $dir_install/etc/vconsole.conf ]]; then
		echo "KEYMAP=$_KEYMAP" >> $dir_install/etc/vconsole.conf
		sed -i -e "s|KEYMAP=.*|KEYMAP=$_KEYMAP|g" $dir_install/etc/vconsole.conf
	else
		sed -i -e "s|#\?KEYMAP=.*|KEYMAP=$_KEYMAP|g" $dir_install/etc/rc.conf
	fi
	evaluate_retval "$?"
}

sh_update_bashrc(){
	msg "INFO" "$(log_info_msg "Ajustando bashrc em $dir_install")"
   [[ ! -e $dir_install/etc/bash/bashrc.d/bashrc.sh ]] && >| $dir_install/etc/bash/bashrc.d/bashrc.sh
	if [[ -f $dir_install/etc/bash/bashrc.d/bashrc.sh ]]; then
		echo "PS1='\e[32;1m\u \e[33;1m→ \e[36;1m\h \e[37;0m\w\n\e[35;1m�# \e[m'" >> $dir_install/etc/bash/bashrc.d/bashrc.sh
	fi
	evaluate_retval "$?"
}

sh_mkfs() {
	msg "INFO" "$(log_info_msg "Formatando particao ${_PART_BOOT} FS ext2")"
	mkfs.ext2 -F -L "EFI" "${_PART_BOOT}" > /dev/null 2>&1
	evaluate_retval "$?"
	msg "INFO" "$(log_info_msg "Formatando particao ${_PART_ROOT} FS ext4")"
	mkfs.ext4 -F -L "VOID" "${_PART_ROOT}" > /dev/null 2>&1
	evaluate_retval "$?"
}

sh_umountfs(){
	msg "INFO" "$(log_info_msg "Desmontando sistema de arquivo em $dir_install")"
	umount -frl "$dir_install" > /dev/null 2>&1
	evaluate_retval "$?"
}

sh_bind() {
	msg "INFO" "$(log_info_msg "Binding sistema de arquivo em $dir_install")"
	mount -t proc  /proc "$dir_install/proc" > /dev/null 2>&1
	mount -t sysfs /sys  "$dir_install/sys"  > /dev/null 2>&1
	mount -o bind  /dev  "$dir_install/dev"  > /dev/null 2>&1
	evaluate_retval "$?"
}

sh_mkuser() {
	#	msg "INFO" "$(log_info_msg "Ajustando root passwd em $dir_install")"
	#	echo -e "${_PASSWD_ROOT}\n${_PASSWD_ROOT}" | chroot $dir_install passwd root > /dev/null 2>&1
	#	evaluate_retval "$?"
	#	msg "INFO" "$(log_info_msg "Criando usuario $_USER e ajustando passwd em $dir_install")"
	#	chroot "$dir_install" /bin/bash -c "useradd -m ${_USER} -G audio,video,wheel,xbuilder -p ${_PASSWD_USER} > /dev/null 2>&1"
	#	chroot "$dir_install" /bin/bash -c "(echo ${_USER}:${_PASSWD_USER}) | chpasswd -m > /dev/null 2>&1"
	#	evaluate_retval "$?"

   if [[ -n "${AsUser[cpassroot]}" ]]; then
      msg "INFO" "$(log_info_msg "$cmsgadduser: root")"
      chroot "$dir_install" /bin/bash -c "(echo root:${AsUser[cpassroot]}) | chpasswd -m > /dev/null 2>&1"
		evaluate_retval "$?"
   fi

	if [[ -n "${AsUser[cuser]}" ]]; then
		msg "INFO" "$(log_info_msg "$cmsgadduser: ${AsUser[cuser]} - ${AsUser[cfullname]} ")"
		chroot "$dir_install" /bin/bash -c "useradd -m ${AsUser[cuser]} -G ${AsUser[cgroups]} -p ${AsUser[cpass]} -c "${AsUser[cfullname]}" > /dev/null 2>&1"
		chroot "$dir_install" /bin/bash -c "(echo ${AsUser[cuser]}:${AsUser[cpass]}) | chpasswd -m > /dev/null 2>&1"
		evaluate_retval "$?"
   fi
}

sh_mkfstab() {
	msg "INFO" "$(log_info_msg "Criando fstab em $dir_install")"
cat > "$dir_install/etc/fstab" <<- EOF
UUID=$(blkid -o value -s UUID "${_PART_BOOT}") /boot	ext2 defaults 0 2
UUID=$(blkid -o value -s UUID "${_PART_ROOT}") / 		ext4 defaults 0 1
EOF
	evaluate_retval "$?"
}

sh_mkservice() {
	msg "INFO" "$(log_info_msg "Configurando services em $dir_install")"
	chroot "$dir_install" /bin/bash -c "ln -s /etc/sv/agetty-tty1 /etc/runit/runsvdir/current/"		> /dev/null 2>&1
	chroot "$dir_install" /bin/bash -c "ln -s /etc/sv/agetty-tty2 /etc/runit/runsvdir/current/"		> /dev/null 2>&1
	chroot "$dir_install" /bin/bash -c "ln -s /etc/sv/dhcpcd /etc/runit/runsvdir/current/"				> /dev/null 2>&1
	chroot "$dir_install" /bin/bash -c "ln -s /etc/sv/wpa_supplicant /etc/runit/runsvdir/current/" 	> /dev/null 2>&1
	chroot "$dir_install" /bin/bash -c "ln -s /etc/sv/udevd /etc/runit/runsvdir/current/"          	> /dev/null 2>&1
	chroot "$dir_install" /bin/bash -c "ln -s /etc/sv/uuidd /etc/runit/runsvdir/current/"				> /dev/null 2>&1
	chroot "$dir_install" /bin/bash -c "ln -s /etc/sv/dmeventd /etc/runit/runsvdir/current/"			> /dev/null 2>&1
	evaluate_retval "$?"
}

sh_mkdir() {
	local cdir
	local adir=("$dir_install/boot"
					"$dir_install/boot/efi"
					"$dir_install/dev"
					"$dir_install/proc"
					"$dir_install/sys"
					"$dir_install/var/db/xbps/keys"
					"$dir_install/etc/xbps.d"
					)

	msg "INFO" "$(log_info_msg "Criando diretorios em $dir_install")"
	for cdir in "${adir[@]}"
	do
		[[ -d "$cdir" ]] || mkdir -p "$cdir"
	done
	evaluate_retval "$?"
}

sh_mount() {
	msg "INFO" "$(log_info_msg "Montando sistema de arquivos em $dir_install")"
	mkdir -p "$dir_install"
	mount "${_PART_ROOT}" "$dir_install"
	mkdir -p "$dir_install/boot"
	mount "${_PART_BOOT}" "$dir_install/boot"
	evaluate_retval "$?"
}

sh_install() {
	local apkgs=(base-system xz lvm2 wireless_tools mkinitcpio mkinitcpio-udev nano grub efivar efibootmgr os-prober)

	sh_umountfs
	if ! sh_mkparted; then die "Erro"; fi
	if ! sh_mkfs 	 ; then die "Erro"; fi
	sh_mount
	sh_mkdir

	msg "INFO" "$(log_info_msg "Instalando rootfs em $dir_install")"
	if tar xpf "$_TARBALL_ROOTFS" --xattrs-include='*.*' --numeric-owner -C $dir_install > /dev/null 2>&1; then
		evaluate_retval "$?"
		sh_bind

		msg "INFO" "$(log_info_msg "Ajustando /etc/resolv.conf em $dir_install")"
		cp /etc/resolv.conf "$dir_install/etc/" > /dev/null 2>&1
		evaluate_retval "$?"

		sh_update_mirror

		msg "INFO" "$(log_info_msg "Atualizando repositorio em $dir_install")"
		chroot "$dir_install" /bin/bash -c "xbps-install -Suy xbps" > /dev/null 2>&1
		evaluate_retval "$?"

		msg "INFO" "$(log_info_msg "Atualizando sistema em $dir_install")"
		chroot "$dir_install" /bin/bash -c "xbps-install -uy" > /dev/null 2>&1
		evaluate_retval "$?"

		#msg "INFO" "$(log_info_msg "Instalando pacotes adicionais $pkg em $dir_install")"
		#chroot "$dir_install" /bin/bash -c "xbps-install -y base-system base-minimal tar xz kmod" > /dev/null 2>&1
		#chroot "$dir_install" /bin/bash -c "xbps-install -y e2fsprogs dosfstools lvm2 sudo iproute2 iputils" > /dev/null 2>&1
		#chroot "$dir_install" /bin/bash -c "xbps-install -y dhcpcd wpa_supplicant wireless_tools iw kbd mdocml" > /dev/null 2>&1
		#chroot "$dir_install" /bin/bash -c "xbps-install -y man-pages vim nano grub efivar efibootmgr os-prober" > /dev/null 2>&1
		#chroot "$dir_install" /bin/bash -c "xbps-install -y mkinitcpio mkinitcpio-udev" > /dev/null 2>&1
		#evaluate_retval "$?"

		for pkg in "${apkgs[@]}"
		do
			msg "INFO" "$(log_info_msg "Instalando $pkg em $dir_install")"
			chroot "$dir_install" /bin/bash -c "xbps-install -y $pkg" > /dev/null 2>&1
			evaluate_retval "$?"
		done

		msg "INFO" "$(log_info_msg "Instalando pacotes adicionais $pkg em $dir_install")"
		chroot "$dir_install" /bin/bash -c "xbps-install -y $_PKGS" > /dev/null 2>&1
		evaluate_retval "$?"

#		msg "INFO" "$(log_info_msg "Instalando kernel em $dir_install")"
#		chroot "$dir_install" /bin/bash -c "xbps-install -y linux linux-headers" > /dev/null 2>&1
#		evaluate_retval "$?"

		msg "INFO" "$(log_info_msg "Instalando grub no $_DEVICE")"
		chroot "$dir_install" /bin/bash -c "grub-install $_DEVICE" > /dev/null 2>&1
		evaluate_retval "$?"

		msg "INFO" "$(log_info_msg "Gerando grub.cfg em $dir_install")"
		chroot "$dir_install" /bin/bash -c "grub-mkconfig -o /boot/grub/grub.cfg" > /dev/null 2>&1
		evaluate_retval "$?"

		msg "INFO" "$(log_info_msg "Removendo pacote bootstrap em $dir_install")"
		chroot "$dir_install" /bin/bash -c "xbps-remove -y base-voidstrap" > /dev/null 2>&1
		evaluate_retval "$?"

		sh_update_hostname
		sh_update_rc
		sh_update_timezone

		msg "INFO" "$(log_info_msg "Reconfigurando locales em $dir_install")"
		chroot "$dir_install" /bin/bash -c "xbps-reconfigure -f glibc-locales" > /dev/null 2>&1
		evaluate_retval "$?"

		sh_update_locale
		sh_mkuser
		sh_mkfstab
		sh_set_keymap
		sh_update_bashrc

		msg "INFO" "$(log_info_msg "Certificando que todos pacotes estejam configurados corretamente em $dir_install")"
		chroot "$dir_install" /bin/bash -c "xbps-reconfigure -fa" > /dev/null 2>&1
		evaluate_retval "$?"

		sh_mkservice
	else
		evaluate_retval "$?"
		die "Erro tar #$?. Problemas para descompactar o tarball $_TARBALL_ROOTFS em $dir_install"
	fi
	sh_umountfs
}

sh_backup_partitions() {
	if [ $# -ge 2 ]; then
		local disk="${1}"
		local device="${2}"
		local cdatetime=$(sh_diahora)
		local tmpdir="/tmp/$_APP_"
		local filetmp="$tmpdir/${device}.$cdatetime.dump"

		mkdir -p $tmpdir 2> /dev/null
		sfdisk -d $disk > $filetmp 2> /dev/null
		#  alerta "BACKUP DA TABELA DE PARTICOES"    \
		#         "Dispositivo : $disk"              \
		#         "  Backup on : ${filetmp}"         \
		#        "$(replicate "=" 80)"               \
		#         "$(cat $filetmp)"
	fi
}

sh_diahora() {
	DIAHORA=`date +"%d%m%Y-%T" | sed 's/://g'`
	printf "%s\n" $DIAHORA
}

now() {
	printf "%(%m-%d-%Y %H:%M:%S)T\n" $(date +%s)
}

sh_setadduser()
{
   # usuario/senha/hostmame/group
   AsUser[cfullname]=""
   AsUser[cuser]="$_USER"
   AsUser[cpass]="$_PASSWD_USER"
   AsUser[cpassroot]="$_PASSWD_ROOT"
   AsUser[chostname]="$_HOSTNAME"
   AsUser[cgroups]="audio,video,wheel,xbuilder"
}

sh_disk_info() {
	unset ARRAY_DSK_{DISKS,DEVICES,SIZE,TRAN,MODEL,LABEL,SERIAL}
	local {NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL}_
	while read line
	do
		eval "${line//=/_=}"
#     [[ -z "$TRAN_" ]] && continue
      ARRAY_DSK_DISKS+=( $NAME_ )
    ARRAY_DSK_DEVICES+=( $PATH_ )
       ARRAY_DSK_SIZE+=( $SIZE_ )
#      ARRAY_DSK_TRAN+=( ${TRAN_:-loop} )
       ARRAY_DSK_TRAN+=( ${TRAN_:-${TYPE_}} )
      ARRAY_DSK_MODEL+=( "${MODEL_:-unknown}" )
      ARRAY_DSK_LABEL+=( "${LABEL_:-""}" )
      ARRAY_DSK_SERIAL+=( "${SERIAL_:-""}" )
	done < <(lsblk -PAo TYPE,NAME,PATH,SIZE,TRAN,MODEL,LABEL,SERIAL | grep -P 'TYPE="(disk|loop|lvm)"' | sort -k5,5 -k2,2)
}

sh_choosedisk() {
	while true
	do
		sh_disk_info
    	LDISK=$false
		local xmsg="$cdisco"
		local array=()
		local i
		local n=0
		local nc=0
		local result
		#local sep="\xe2\x94\x82"
		local sep=" | "

		for i in "${ARRAY_DSK_DEVICES[@]}"
		do
         array[((n++))]="$i"
         array[((n++))]=$(printf "%-6s$sep%6s$sep%-30s" "${ARRAY_DSK_TRAN[$nc]}" "${ARRAY_DSK_SIZE[$nc]}" "${ARRAY_DSK_MODEL[$nc]}")
			((nc++))
		done

    	sd=$(${DIALOG}  																				\
    				--title 			"$xmsg"								  							\
    				--backtitle	 	"$ccabec"				 										\
    				--cancel-label "$buttonback"													\
    				--colors																				\
	            --extra-button                                                    \
               --extra-label  "$buttonpart"                                      \
    				--menu 			"\n$cchoosedisk" 0 0 10 "${array[@]}" 2>&1 >/dev/tty 	)

    	exit_status=$?
		case $exit_status in
    	"$D_ESC"|"$D_CANCEL")
			"$DIALOG" --clear --backtitle "$backtitle" --yesno "Deseja sair sem instalar?" 0 0
			case $? in
	      	"$D_OK")
					die "Finalizando..."
             	break
	            ;;
				"$D_CANCEL")
					exit_status=99
					continue
					;;
			esac
    		;;
		3)
      	result=$(fdisk -l "$sd");
         display_result "$result" "$cmsg013" "$cmsg_part_disk"
         continue
         ;;
		esac

    	if [[ -n "$sd" ]]; then
			{	local item
            index=0
            for item in "${ARRAY_DSK_DEVICES[@]}"
            do
            	[[ "$item" = "$sd" ]] && { break; }
               ((index++))
            done
			}
			DEVICE_ORIGEM="${ARRAY_DSK_DISKS[index]}"
			_DEVICE="/dev/$DEVICE_ORIGEM"
			MODEL_ORIGEM="${ARRAY_DSK_MODEL[index]}"
			SIZE_ORIGEM="${ARRAY_DSK_SIZE[index]}"
			TRAN_ORIGEM="${ARRAY_DSK_TRAN[index]}"
			sh_backup_partitions "${sd}" "${DEVICE_ORIGEM}"
			return 0
		fi
    	break
	done
}

display_result() {
	local xbacktitle=$ccabec
	if [[ "$3" != "" ]] ; then
		xbacktitle="$3"
	fi
	${DIALOG}   --title  "$2"              \
               --beep                     \
               --no-collapse              \
               --no-cr-wrap               \
               --backtitle "$xbacktitle"  \
               --msgbox    "$1"           \
               00 0
}

sh_confadduser()
{
   while true
   do
      exec 3>&1
         usertext=$(${DIALOG}                         \
         --backtitle       "$cmsgusermanager"         \
         --insecure        "$@"                       \
         --mixedform       "$ccreatenewuser"          \
         14 50 0                                      \
         "Nome Completo : " 1 1 "${AsUser[cfullname]}"    1 17 40 0 0 \
         "Username      : " 2 1 "${AsUser[cuser]}"        2 17 20 0 0 \
         "Password user : " 3 1 "${AsUser[cpass]}"        3 17 20 0 1 \
         "Password root : " 4 1 "${AsUser[cpassroot]}"    4 17 20 0 1 \
         "Hostname      : " 5 1 "${AsUser[chostname]}"    5 17 20 0 0 \
         "Disco destino : " 6 1 "${_DEVICE}"              6 17 20 0 2 \
         "Tam/Modelo    : " 7 1 "${SIZE_ORIGEM}/${MODEL_ORIGEM}"        7 17 20 0 2 \
         2>&1 1>&3)
         exit_status=$?

         case $exit_status in
            "$D_ESC"|"$D_CANCEL")
		         "$DIALOG" --clear --backtitle "$backtitle" --yesno "Deseja sair sem instalar?" 0 0
		         case $? in
		            "$D_OK")
		               die "Finalizando..."
		               break
		               ;;
		            "$D_CANCEL")
		               exit_status=99
							continue
		               ;;
		         esac
		         ;;
            "$D_OK")
               mapfile -t <<< "$usertext" aUser
               AsUser[cfullname]="${aUser[0]}"
               AsUser[cuser]="${aUser[1]}"
               AsUser[cpass]="${aUser[2]}"
               AsUser[cpassroot]="${aUser[3]}"
               AsUser[chostname]="${aUser[4]}"
               _HOSTNAME="${aUser[4]}"

               if [[ "${AsUser[cuser]}" == "root" ]]; then
                  if ! conf "*** USER ***" "\nUsuario não pode ser root! Novamente?"; then
                     die "*** USER *** " "Cadastro de usuario cancelado"
                     return 1
                  fi
                  sh_confadduser
               fi

               if [[ -z "${AsUser[cuser]}" ]]; then
                  if ! conf "*** USER ***" "\nUsuario não pode ser vazio! Novamente?"; then
                     die "*** USER *** " "Cadastro de usuario cancelado"
                     return 1
                  fi
                  sh_confadduser
               fi

               if [[ -z "${AsUser[cpass]}" ]]; then
                  if ! conf "*** USER ***" "\nSenha do usuario não pode ser vazia! Novamente?"; then
                     die "*** USER *** " "Cadastro de usuario cancelado"
                     return 1
                 fi
                  sh_confadduser
               fi
               log_info_msg 'Configurações efetuadas. Prosseguindo com instalação.'
					evaluate_retval "$?"
               ;;
         esac
      exec 3>&-
      return 0
   done
}

sh_dryrun(){
	sh_umountfs
	sh_mount
	sh_bind
	sh_update_rc
	sh_update_mirror
	sh_update_timezone
	sh_set_keymap
	sh_update_bashrc
	chroot "$dir_install" /bin/bash
	sh_umountfs
}

sh_ambiente
sh_ascii_lines
setvarcolors
log_prefix
msg "INFO" "$(log_info_msg "Configurando ambiente")"
sh_checkroot
checkDependencies
evaluate_retval "$?"
msg "INFO" "$(log_info_msg "Sanitizando ambiente")"
sh_config
evaluate_retval "$?"
sh_checknet "$URL_GOOGLE" || return 1
sh_checktarball
sh_choosedisk
sh_confadduser
#sh_dryrun
sh_install
